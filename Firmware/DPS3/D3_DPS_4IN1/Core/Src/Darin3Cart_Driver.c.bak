/*
 * Darin3Cartridge.c
 *
 *  Created on: 10-Aug-2023
 *      Author: Vijay
 */
#if 1
#include "stm32f4xx_hal.h"
#include "main.h"
#include "Darin3Cart_Driver.h"

uint16_t CF_WE  = WE_Pin;
uint16_t CF_RST = RESET_Pin;
uint16_t CF_OE  = ATA_SEL_Pin;
//uint16_t CF_CE  = CSO_1_Pin;

uint16_t A0  = A00_Pin;
uint16_t A1  = A01_Pin;
uint16_t A2  = A02_Pin;
uint16_t A3  = A03_Pin;

uint16_t Address_Flash_Page1 = 0;

uint16_t sector_number = 0;

#define data_reg 	   0x00
#define feature        0x01
#define sector_count   0x02
#define sector_num     0x03
#define cyc_low        0x04
#define cyc_high       0x05
#define drive          0x06
#define command        0x07
#define status_reg     0x07

uint16_t M_D7  = DB7_Pin;
uint16_t M_D6  = DB6_Pin;
uint16_t M_D5  = DB5_Pin;
uint16_t M_D4  = DB4_Pin;
uint16_t M_D3  = DB3_Pin;
uint16_t M_D2  = DB2_Pin;
uint16_t M_D1  = DB1_Pin;
uint16_t M_D0  = DB0_Pin;

uint16_t CF_CE[4]  = {CSO_1_Pin, CSO_2_Pin, CSO_3_Pin, CSO_4_Pin};
uint16_t CD2_SLT[4]  = {CD2_SLT_S1_Pin, CD2_SLT_S2_Pin, CD2_SLT_S3_Pin, CD2_SLT_S4_Pin};
static uint8_t SLT_STATUS[4]  = {1, 1, 1, 1};
static const uint16_t GREEN_LED[] = { LED1_Pin, LED3_Pin, LED5_Pin, LED7_Pin };
static const uint16_t RED_LED[] = { LED2_Pin, LED4_Pin, LED6_Pin, LED8_Pin };

uint16_t get_CE_pin(CartridgeID id) {
    return CF_CE[id];
}

uint16_t get_CD2SLT_pin(CartridgeID id) {
    return CD2_SLT[id];
}

uint16_t get_D3_slt_status(CartridgeID id) {
    return SLT_STATUS[id];
}

void DataBus_SetOutput(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    GPIO_InitStruct.Pin = M_D0 | M_D1 | M_D2 | M_D3 |
                         M_D4 | M_D5 | M_D6 | M_D7;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;

    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
}

void DataBus_SetInput(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    GPIO_InitStruct.Pin = M_D0 | M_D1 | M_D2 | M_D3 |
                         M_D4 | M_D5 | M_D6 | M_D7;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;

    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
}

typedef enum {
    DIR_INPUT = 0,
    DIR_OUTPUT = 1
} DataBusDirection;


void DataBus_Configure(DataBusDirection direction)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // All data pins
    GPIO_InitStruct.Pin = M_D0 | M_D1 | M_D2 | M_D3 |
                         M_D4 | M_D5 | M_D6 | M_D7;

    if(direction == DIR_OUTPUT)
    {
        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
    }
    else  // DIR_INPUT
    {
        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
    }

    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
}

//****************************************************************************
//****************************************************************************
// COMPACT FLASH READ OPERATION
//****************************************************************************
//****************************************************************************
void read_compact_flash(uint8_t *TempStorage, CartridgeID id)//this initiates the complete read cycle for  compact flash
{
 pre_read_compact_flash(id);	                 //function to pre intialise the ports to compact flash
 compact_flash_ready();	                     //function to find wheather the compact flash is ready or not
 command_for_read();		                 //function to intiate read command for compact flash
 check_stat_of_compact_flash();              //function to check wheather the command is initiated properly or not
 compact_flash_read(TempStorage,512);		 //function to read the data from the compact flash and store in XRAM location
 post_read_compact_flash(id);                  //reset the mode of all the ports to input
}
//****************************************************************************
//PRE_READ_COMPACT_FLASH
//****************************************************************************
void pre_read_compact_flash(CartridgeID id)//function to pre intialise the ports to compact flash
{
 DataBus_Configure(DIR_INPUT);
 write_address_port(0);
 HAL_GPIO_WritePin(GPIOD,CF_WE,1);				//disable write signal
 HAL_GPIO_WritePin(GPIOB,CF_OE,1);				//disable output enable of compact flash
 HAL_GPIO_WritePin(GPIOD,get_CE_pin(id),0);
 HAL_GPIO_WritePin(GPIOD,CF_RST,1);				//Enable reset
 short_delay_us(50);
 HAL_GPIO_WritePin(GPIOD,CF_RST,0);				//disable reset
 short_delay_us(250);
}
//****************************************************************************
//COMMAND_FOR _READ
//****************************************************************************
void command_for_read(void)						 //function to intiate read command for compact flash
{
	DataBus_Configure(DIR_OUTPUT);					 //set the mode of port p1 as output port
 write_address_port(sector_count); 				 //address the register pointer of CF to sector counter register
 DataBus_WriteByte( 0x01);								 //since single page is accessed at a time put value 0x01 into port p1
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);	         //intiate write so that that value 0x01 is stored in
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);			 //sector count register
 write_address_port(sector_num);				 //address the register pointer of CF to sector number register
 DataBus_WriteByte( sector_number);  					 //send the sector number from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);			 //intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(cyc_low);					 //address the register pointer of CF to cylinder low register
 DataBus_WriteByte(Address_Flash_Page1);				 //send the cylinder low value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);			 //intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(cyc_high);					 //address the register pointer of CF to cylinder high register
 DataBus_WriteByte(Address_Flash_Page1  >> 8);			 //send the cylinder high value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);			 //intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(drive);						 //address the register pointer of CF to drive register
 DataBus_WriteByte(0xE0);								 //send the drive value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);			 //intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(command);					 //address the register pointer of CF to comand register
 DataBus_WriteByte(0x20);								 //send the command value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);			 //intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 short_delay_us(5);									 //call delay function
 DataBus_Configure(DIR_INPUT);					 //set the mode of port p1 as input port
}
//****************************************************************************
//POST_READ_COMPACT_FLASH
//****************************************************************************
void compact_flash_read(uint8_t *TempStorage,uint16_t datalength)
{
 write_address_port(data_reg) ;				 //address the register pointer to point to data regester
 DataBus_Configure(DIR_INPUT);				 //ready to access data from the CF
 for (uint16_t x=0 ;x<datalength ;x++)		 //if data counter 'x'<512 then
 {
  HAL_GPIO_WritePin(GPIOB, CF_OE, 0);		 //activate the output enable of CF
  *TempStorage = DataBus_ReadByte();				 //read the data from the CF and store it in address specified by 'pread'
  HAL_GPIO_WritePin(GPIOB, CF_OE, 1);	     //disbale output enable of CF
  TempStorage++;							 //increment 'pread'
 }
}
//****************************************************************************
//POST_READ_COMPACT_FLASH
//****************************************************************************
void post_read_compact_flash(CartridgeID id)				 //reset the mode of all the ports to input
{
 HAL_GPIO_WritePin(GPIOD, get_CE_pin(id), 1);	    //disable compact flash chip
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);	    //disable write enable signal
 HAL_GPIO_WritePin(GPIOD, CF_RST,1);	    //disable reset signal of compact flash
 HAL_GPIO_WritePin(GPIOB, CF_OE, 1);	    //disable output enable of compact flash
}


//****************************************************************************
//****************************************************************************
// COMPACT FLASH WRITE OPERATION
//****************************************************************************
//****************************************************************************
void write_compact_flash(uint8_t* TempStorage, CartridgeID id)	//this initiates the complete write cycle for compact flash
{
 pre_write_compact_flash(id);	                    //this function initiates pre port settings for CF write
 compact_flash_ready();		                    //this is used to check wheather CF is ready for write operation
 command_for_write();			                //this function is used to initiate write command to CF
 check_stat_of_compact_flash();                 //this function is used to check the status of write command
 compact_flash_write(TempStorage,512);		    //if command was sucessesful then start writing data to CF
 post_write_compact_flash(id);	                //this function used to reset the mode of ports
}
//****************************************************************************
//PRE_WRITE_COMPACT_FLASH
//****************************************************************************
void pre_write_compact_flash(CartridgeID id)              //this function initiates pre port settings for CF write
{
 DataBus_Configure(DIR_INPUT);
 write_address_port(0);
 HAL_GPIO_WritePin(GPIOD,CF_WE,1);				//disable write signal
 HAL_GPIO_WritePin(GPIOB,CF_OE,1);				//disable output enable of compact flash
 HAL_GPIO_WritePin(GPIOD,get_CE_pin(id),0);
 HAL_GPIO_WritePin(GPIOD,CF_RST,1);				//Enable reset
 short_delay_us(50);
 HAL_GPIO_WritePin(GPIOD,CF_RST,0);				//disable reset
 short_delay_us(250);
}
//****************************************************************************
//COMPACT_FLASH_READY
//****************************************************************************
unsigned char compact_flash_ready(void)         //function to find wheather the compact flash is ready or not
{
 unsigned char reg_status;
 write_address_port(status_reg);                //send 0x07 to CF so that select status register of CF
 short_delay_us(5);			                        //call delay function
 unsigned int BusyCnt;

 BusyCnt = 0;
 do                   	                        //check for error if one it means previous
 {						                        //command was ended with error
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;
 }while(((reg_status & 0x80) == 0x80) && (BusyCnt<5000));

 BusyCnt = 0;
 do                   	                        //check for error if one it means previous
 {						                        //command was ended with error
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;
 }while(((reg_status & 0x40) == 0x00) && (BusyCnt<5000));

 BusyCnt = 0;
 do                   	                        //check for error if one it means previous
 {						                        //command was ended with error
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;
 }while(((reg_status & 0x10) == 0x00) && (BusyCnt<5000));
 return reg_status;
}
//****************************************************************************
//COMMAND_FOR _WRITE
//****************************************************************************
void command_for_write()	                    //this function is used to initiate write command to CF
{
	DataBus_Configure(DIR_OUTPUT);		                //set the mode of port p1 as output port
 write_address_port(sector_count); 				//address the register pointer of CF to sector counter register
 DataBus_WriteByte(0x01);								//since single page is accessed at a time put value 0x01 into port p1
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);    		//initiate write so that that value 0x01 is stored in
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);    		//sector count register
 write_address_port(sector_num);	    		//address the register pointer of CF to sector number register
 DataBus_WriteByte(sector_number);			    		//send the sector number from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);    		//initiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(cyc_low);		    		//address the register pointer of CF to cylinder low register
 DataBus_WriteByte(Address_Flash_Page1);				//send the cylinder low value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);    		//initiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(cyc_high);		    		//address the register pointer of CF to cylinder high register
 DataBus_WriteByte(Address_Flash_Page1 >> 8);			//send the cylinder high value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);    		//initiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(drive);			    		//address the register pointer of CF to drive register
 DataBus_WriteByte(0xE0);								//send the drive value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);    		//initiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(command);					//address the register pointer of CF to comand register
 DataBus_WriteByte(0x30);								//send the command value from which you want to WRITE the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);    		//initiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 DataBus_Configure(DIR_INPUT);
}
//****************************************************************************
//CHEAK_STATUS_FOR_COMPACT_FLASH
//****************************************************************************
unsigned char check_stat_of_compact_flash(void)	//function to check wheather the command is initiated properly or not
{
 unsigned char reg_status;
 write_address_port(status_reg);				//address the register pointer to point to status regester
 short_delay_us(5);								    //wait for some delay //if error then quit
 unsigned int BusyCnt;

 BusyCnt = 0;
 do
 {
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;
 }while(((reg_status & 0x80) == 0x80)&& (BusyCnt < 500000));

 BusyCnt = 0;
 do
 {
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;;
 }while(((reg_status & 0x40) == 0x00) && (BusyCnt < 500000));

 BusyCnt = 0;
 do
 {
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;
 }while(((reg_status & 0x10) == 0x00) && (BusyCnt < 500000));

 BusyCnt = 0;
 do
 {
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;
 }while(((reg_status & 0x08) == 0x00) && (BusyCnt < 500000));

 BusyCnt = 0;
 do
 {
  HAL_GPIO_WritePin(GPIOB,CF_OE,0);
  reg_status = DataBus_ReadByte();
  HAL_GPIO_WritePin(GPIOB,CF_OE,1);
  BusyCnt++;
 }while(((reg_status & 0x01) == 0x01) && (BusyCnt < 500000));
 return reg_status;
}
//****************************************************************************
//WRITE_COMPACT_FLASH
//****************************************************************************
void compact_flash_write(uint8_t* TempStorage,uint16_t datalength)	//if command was sussesful then start writing data to CF
{
 unsigned char busy;
 DataBus_Configure(DIR_OUTPUT);					//set the mode of port p1 as output port
 write_address_port(data_reg);				//address the register pointer to point to data regester
 short_delay_us(5);
 for (uint16_t x=0 ;x<datalength ;x++)      //if data counter value <last page size then
 {
  DataBus_WriteByte(*TempStorage) ;			    //read the data from XRAM location load it into the CF
  HAL_GPIO_WritePin(GPIOD, CF_WE, 0);
  HAL_GPIO_WritePin(GPIOD, CF_WE, 1);	    //disable write signal of compact flash
  TempStorage++;					        //increment XRAM pointer
 }
 DataBus_Configure(DIR_INPUT);
 write_address_port(status_reg);
 HAL_GPIO_WritePin(GPIOB, CF_OE, 0);
 do                   	                    //check for error if one it means previous
 {						                    //command was ended with error
  busy = DataBus_ReadByte();
 }while((busy & 0x80) == 0x80);
 HAL_GPIO_WritePin(GPIOB, CF_OE, 1);
}
//****************************************************************************
//POST_WRITE_COMPACT_FLASH
//****************************************************************************
void post_write_compact_flash(CartridgeID id)
{
 HAL_GPIO_WritePin(GPIOD, get_CE_pin(id), 1);	    //disable compact flash chip
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);	    //disable write enable signal
 HAL_GPIO_WritePin(GPIOD, CF_RST,1);	    //disable reset signal of compact flash
 HAL_GPIO_WritePin(GPIOB, CF_OE, 1);	    //disable output enable of compact flash
}
//****************************************************************************
//****************************************************************************
//
//****************************************************************************
//****************************************************************************
uint8_t D3_Cartridge_Check()
{
 GPIO_InitTypeDef GPIO_InitStruct = {0};
 GPIO_InitStruct.Pin =  POWER_CYCLE_1_Pin;
 GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 GPIO_InitStruct.Pull = GPIO_PULLUP;
 HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 return HAL_GPIO_ReadPin(GPIOD, POWER_CYCLE_1_Pin);
}

//****************************************************************************
//
//****************************************************************************
void write_address_port(uint8_t data)
{
 HAL_GPIO_WritePin(GPIOD, A3, ((data & 0x08) >> 3));
 HAL_GPIO_WritePin(GPIOD, A2, ((data & 0x04) >> 2));
 HAL_GPIO_WritePin(GPIOD, A1, ((data & 0x02) >> 1));
 HAL_GPIO_WritePin(GPIOD, A0, (data & 0x01));
}
//****************************************************************************
//POST_READ_COMPACT_FLASH
//****************************************************************************
uint8_t Read_address_port()
{
 uint8_t ret =
 (HAL_GPIO_ReadPin(GPIOD, A3) << 3) |
 (HAL_GPIO_ReadPin(GPIOD, A2) << 2) |
 (HAL_GPIO_ReadPin(GPIOD, A1) << 1) |
 (HAL_GPIO_ReadPin(GPIOD, A0));
 return ret;
}
//****************************************************************************
//
//****************************************************************************
void generic_CF_CMD(unsigned char sector_num1,unsigned char Cmd, unsigned char CylinderLow, unsigned char CylinderHigh)	//this function is used to initiate write command to CF
{
	DataBus_Configure(DIR_OUTPUT);		                        //set the mode of port p1 as output port
 write_address_port(sector_count); 				        //address the register pointer of CF to sector counter register
 DataBus_WriteByte(0x01);						                //since single page is accessed at a time put value 0x01 into port p1
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);					//intiate write so that that value 0x01 is stored in
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);					//sector count register
 write_address_port(sector_num);				        //address the register pointer of CF to sector number register
 DataBus_WriteByte(sector_num1);			                    //send the sector number from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);					//intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(cyc_low);					        //address the register pointer of CF to cylinder low register
 DataBus_WriteByte(CylinderLow);		                        //send the cylinder low value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);					//intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(cyc_high);					        //address the register pointer of CF to cylinder high register
 DataBus_WriteByte(CylinderHigh);	                            //send the cylinder high value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);					//intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(drive);					            //address the register pointer of CF to drive register
 DataBus_WriteByte(0xE0);						                //send the drive value from which you want to read the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);					//intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 write_address_port(command);					        //address the register pointer of CF to comand register
 DataBus_WriteByte(Cmd);						                //send the command value from which you want to WRITE the data
 HAL_GPIO_WritePin(GPIOD, CF_WE, 0);					//intiate the write signal
 HAL_GPIO_WritePin(GPIOD, CF_WE, 1);
 DataBus_Configure(DIR_INPUT);
}

void TesCompactFlashDriver(CartridgeID id)
{
	uint8_t *data;
	uint8_t TxdataBuff[512];
	data = (uint8_t *)malloc(512*sizeof(uint8_t));

	uint16_t i=0,j=0;
	for(i=0;i<512;i++,j++)
	{
		data[i] = j;
		if(j==255)
			j=0;
	}
	write_compact_flash(&data[0], id);
	read_compact_flash(&TxdataBuff[0], id);
	free(data);

}

// Write with setup/hold time
void DataBus_WriteByte(uint8_t data)
{
    // Set data on bus
    GPIOE->BSRR = (0xFF << 16) | data;

    // Small delay for setup time (adjust as needed)
    __NOP(); __NOP(); __NOP(); __NOP();  // A few CPU cycles delay
}

// Read with proper timing
uint8_t DataBus_ReadByte(void)
{
    uint8_t data;

    // Small delay before reading (adjust as needed)
    __NOP(); __NOP(); __NOP(); __NOP();

    // Read data
    data = (uint8_t)(GPIOE->IDR & 0xFF);

    return data;
}

void UpdateD3SlotStatus()
{
	for(int itr=0;itr<4;itr++)
	{
		if( 0 == HAL_GPIO_ReadPin(GPIOC, CD2_SLT[itr]))
		{
			SLT_STATUS[itr] = 0x03;
		}
		else
		{
			SLT_STATUS[itr] = 0x00;
		}
	}
}

uint16_t get_D3_Green_LedPins(CartridgeID id) {
    return GREEN_LED[id];
}

uint16_t get_D3_Red_LedPins(CartridgeID id) {
    return RED_LED[id];
}

void setGreenLed(CartridgeID id, uint8_t value)
{
	if(value ==1)
	HAL_GPIO_WritePin(GPIOA, get_D3_Green_LedPins(id)
			    				   , GPIO_PIN_SET);
	else
		HAL_GPIO_WritePin(GPIOA, get_D3_Green_LedPins(id)
					    				   , GPIO_PIN_RESET);
}
void setRedLed(CartridgeID id, uint8_t value)
{
	if(value ==1)
	HAL_GPIO_WritePin(GPIOA, get_D3_Red_LedPins(id)
			    				   , GPIO_PIN_SET);
	else
		HAL_GPIO_WritePin(GPIOA, get_D3_Red_LedPins(id)
					    				   , GPIO_PIN_RESET);
}

void short_delay_us(uint32_t us) {
    for (volatile uint32_t i = 0; i < us * 8; i++) {
        __NOP();  // One NOP ~1 cycle
    }
}

#endif
